<!DOCTYPE html>
<html>
<head>
    <title>卫星影像建筑物提取</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-measure/dist/leaflet-measure.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://unpkg.com/leaflet-measure/dist/leaflet-measure.js"></script>
    <script src="https://unpkg.com/leaflet-fullscreen/dist/Leaflet.fullscreen.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-fullscreen/dist/leaflet.fullscreen.css" />
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            background-color: #f5f5f7;
        }
        #sidebar {
            width: 320px;
            background-color: #ffffff;
            padding: 20px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            z-index: 1000;
        }
        #main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        #mapid {
            flex-grow: 1;
        }
        h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        .control-group input, .control-group select {
            width: 100%;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #dcdcdc;
            font-size: 14px;
            box-sizing: border-box;
        }
        .mode-selector {
            display: flex;
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #007aff;
        }
        .mode-selector button {
            flex-grow: 1;
            padding: 10px;
            background-color: #ffffff;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #007aff;
            transition: background-color 0.2s, color 0.2s;
        }
        .mode-selector button.active {
            background-color: #007aff;
            color: #ffffff;
        }
        .mode-selector button:first-child {
            border-right: none;
        }
        .action-buttons button {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 10px;
        }
        #btn-clear {
            background-color: #f0f0f0;
            color: #333;
        }
        .button-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .secondary-button {
            flex-grow: 1;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #dcdcdc;
            background-color: #f0f0f0;
            color: #333;
            font-size: 14px;
            cursor: pointer;
            margin: 0 5px;
        }
        .secondary-button:first-child {
            margin-left: 0;
        }
        .secondary-button:last-child {
            margin-right: 0;
        }
        #btn-export {
            background-color: #34c759;
            color: white;
        }
        #btn-export:disabled {
            background-color: #e5e5e5;
            color: #a8a8a8;
            cursor: not-allowed;
        }
        #spinner {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 8px solid #f3f3f3;
            border-top: 8px solid #007aff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            z-index: 2000;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .leaflet-draw-toolbar a {
            background-color: white !important;
            color: #007aff !important;
            border-radius: 4px !important;
        }
        .downloaded-image-overlay {
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5) !important;
            border: 2px solid #007aff !important;
            border-radius: 4px !important;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
        
        .downloaded-image-overlay:hover {
            opacity: 1;
        }
        
        /* 地图工具栏样式 */
        .leaflet-control-toolbar {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .leaflet-control-toolbar a {
            background-color: white !important;
            color: #007aff !important;
            border-radius: 4px !important;
            margin: 2px;
            transition: all 0.2s;
        }
        
        .leaflet-control-toolbar a:hover {
            background-color: #f0f8ff !important;
            transform: scale(1.05);
        }
        
        /* 测量工具样式 */
        .leaflet-measure-control {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        /* 编辑模式提示 */
        .edit-mode-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 122, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>建筑物智能提取</h1>

        <div class="control-group">
            <label>切换模式</label>
            <div class="mode-selector">
                <button id="btn-point-mode" class="active" onclick="setMode('point')">点选模式</button>
                <button id="btn-box-mode" onclick="setMode('box')">框选模式</button>
            </div>
        </div>

        <div class="control-group">
            <label for="baseMapSelector">切换底图</label>
            <select id="baseMapSelector" onchange="changeBaseMap()">
                <option value="esri">卫星图</option>
                <option value="osm">街道图</option>
            </select>
        </div>

        <div class="control-group">
            <label for="modelSelector">选择模型</label>
            <select id="modelSelector" onchange="switchModel()">
                <option value="">加载中...</option>
            </select>
        </div>

        <div id="model-status" style="margin-top: -15px; margin-bottom: 15px; font-size: 12px; color: #666;"></div>

        <div class="control-group">
                <label for="threshold-slider">预测阈值: <span id="threshold-value">0.5</span></label>
                <input type="range" id="threshold-slider" min="0.1" max="0.9" step="0.05" value="0.5" style="width: 100%;" oninput="document.getElementById('threshold-value').textContent = this.value">
            </div>

        <div class="control-group">
            <label for="min-area-slider">最小面积 (像素): <span id="min-area-value">10</span></label>
            <input type="range" id="min-area-slider" min="0" max="100" step="1" value="10" style="width: 100%;" oninput="document.getElementById('min-area-value').textContent = this.value">
        </div>

        <div class="control-group">
            <label for="lon">经度</label>
            <input type="number" id="lon" value="114.29" step="0.00001">
        </div>
        <div class="control-group">
            <label for="lat">纬度</label>
            <input type="number" id="lat" value="30.59" step="0.00001">
        </div>
        <div class="control-group">
            <button onclick="updateMapCenter()" style="width:100%; padding: 10px; border-radius: 8px; border: 1px solid #007aff; background-color: #fff; color: #007aff; cursor: pointer;">定位到经纬度</button>
        </div>

        <div class="action-buttons">
            <div class="button-row">
                <button id="btn-toggle-map" class="secondary-button" onclick="toggleStaticMapVisibility()">显示/隐藏图片</button>
                <button id="btn-clear" class="secondary-button" onclick="clearAll()">清除识别</button>
            </div>
            <div class="button-row">
                <button id="btn-edit-mode" class="secondary-button" onclick="toggleEditMode()">编辑建筑物</button>
                <button id="btn-add-marker" class="secondary-button" onclick="toggleMarkerMode()">添加标记点</button>
            </div>
            <button id="btn-export" onclick="exportShp()" disabled>导出 SHP</button>
        </div>
    </div>

    <div id="main-content">
        <div id="mapid"></div>
        <div id="spinner"></div>
        <div id="edit-hint" class="edit-mode-hint">编辑模式：点击建筑物多边形进行编辑</div>
    </div>

    <script>
        var map = L.map('mapid', {
            zoomControl: false, // 禁用默认缩放控件
            fullscreenControl: true, // 启用全屏控件
            fullscreenControlOptions: {
                position: 'topleft'
            },
            maxZoom: 22 // 设置地图最大缩放级别以便精确编辑
        }).setView([30.585774, 114.288390], 18); // 以武汉CBD为中心
        
        var staticMapLayers = L.layerGroup();
        var buildingLayer;
        var currentGeoJSON = null;
        let currentMode = 'point'; // '点选' 或 '框选'
        let editMode = false;
        let markerMode = false;
        var drawnItems = new L.FeatureGroup();
        var markerLayer = new L.FeatureGroup();
        map.addLayer(drawnItems);
        map.addLayer(markerLayer);
        var drawControl;
        
        // 添加自定义缩放控件
        L.control.zoom({
            position: 'topleft'
        }).addTo(map);
        
        // // 添加测量工具
        // var measureControl = new L.Control.Measure({
        //     position: 'topleft',
        //     primaryLengthUnit: 'meters',
        //     secondaryLengthUnit: 'kilometers',
        //     primaryAreaUnit: 'sqmeters',
        //     secondaryAreaUnit: 'hectares',
        //     activeColor: '#007aff',
        //     completedColor: '#ff7800'
        // });
        // measureControl.addTo(map);
        
        // 添加坐标显示控件
        var coordsControl = L.control({position: 'bottomright'});
        coordsControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'leaflet-control-coords');
            div.style.background = 'rgba(255, 255, 255, 0.9)';
            div.style.padding = '5px 10px';
            div.style.borderRadius = '4px';
            div.style.fontSize = '12px';
            div.innerHTML = '经度: 0.000000, 纬度: 0.000000';
            return div;
        };
        coordsControl.addTo(map);
        
        // 添加缩放级别显示控件
        var zoomControl = L.control({position: 'bottomleft'});
        zoomControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'leaflet-control-zoom-level');
            div.style.background = 'rgba(255, 255, 255, 0.9)';
            div.style.padding = '5px 10px';
            div.style.borderRadius = '4px';
            div.style.fontSize = '12px';
            div.style.fontWeight = 'bold';
            div.innerHTML = '缩放级别: ' + map.getZoom();
            return div;
        };
        zoomControl.addTo(map);
        
        // 更新坐标显示
        map.on('mousemove', function(e) {
            var coords = document.querySelector('.leaflet-control-coords');
            if (coords) {
                coords.innerHTML = `经度: ${e.latlng.lng.toFixed(6)}, 纬度: ${e.latlng.lat.toFixed(6)}`;
            }
        });
        
        // 更新缩放级别显示
        map.on('zoomend', function() {
            var zoomLevel = document.querySelector('.leaflet-control-zoom-level');
            if (zoomLevel) {
                zoomLevel.innerHTML = '缩放级别: ' + map.getZoom();
            }
        });

        var osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 22, // 增加最大缩放级别以便精确编辑
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        });

        var Esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 22, // 增加最大缩放级别以便精确编辑
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

                Esri_WorldImagery.addTo(map); // 默认使用Esri World Imagery图层

        // 更新changeBaseMap函数以处理新图层
                function changeBaseMap() {
            var selector = document.getElementById('baseMapSelector');
            var selectedValue = selector.value;

            map.eachLayer(function (layer) {
                if (layer === osmLayer || layer === Esri_WorldImagery) {
                    map.removeLayer(layer);
                }
            });

            if (selectedValue === 'osm') {
                osmLayer.addTo(map);
            } else if (selectedValue === 'esri') {
                Esri_WorldImagery.addTo(map);
            }
        }



        

                function clearAll() {
            clearAllLayers();
        }

        

        document.addEventListener('DOMContentLoaded', function() {
            fetchModels();
        });

        async function fetchModels() {
            try {
                const response = await fetch('/get_models');
                if (!response.ok) {
                    throw new Error('无法获取模型列表');
                }
                const data = await response.json();
                const modelSelector = document.getElementById('modelSelector');
                const modelStatus = document.getElementById('model-status');

                modelSelector.innerHTML = ''; // 清空加载提示

                if (data.models && data.models.length > 0) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = model.name + (model.available ? '' : ' (不可用)');
                        option.disabled = !model.available;
                        if (model.name === data.current) {
                            option.selected = true;
                        }
                        modelSelector.appendChild(option);
                    });
                    modelStatus.textContent = `当前模型: ${data.current}`;
                } else {
                    modelSelector.innerHTML = '<option>无可用模型</option>';
                    modelStatus.textContent = '无可用模型';
                }
            } catch (error) {
                console.error('获取模型列表失败:', error);
                const modelSelector = document.getElementById('modelSelector');
                modelSelector.innerHTML = '<option>加载失败</option>';
                document.getElementById('model-status').textContent = '模型加载失败';
            }
        }

        async function switchModel() {
            const modelSelector = document.getElementById('modelSelector');
            const selectedModel = modelSelector.value;
            const modelStatus = document.getElementById('model-status');
            
            showSpinner(true);
            modelStatus.textContent = `正在切换到: ${selectedModel}...`;

            try {
                const response = await fetch('/switch_model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_name: selectedModel })
                });

                if (!response.ok) {
                    throw new Error('模型切换失败');
                }

                const data = await response.json();
                if (data.success) {
                    modelStatus.textContent = `当前模型: ${selectedModel}`;
                    alert(data.message);
                } else {
                    throw new Error(data.message);
                }
            } catch (error) {
                console.error('切换模型失败:', error);
                alert('切换模型失败: ' + error.message);
                // 切换失败时，重新获取模型列表以同步状态
                fetchModels(); 
            } finally {
                showSpinner(false);
            }
        }

        function onMapClick(e) {
            const { lat, lng } = e.latlng;
            document.getElementById('lat').value = lat.toFixed(6);
            document.getElementById('lon').value = lng.toFixed(6);

            // 在编辑模式或标记模式下不执行点选功能
            if (currentMode !== 'point' || editMode || markerMode) return;

            const zoom = map.getZoom();

            // 调用点选预测API，传递当前地图缩放级别
            predictForPoint(lat, lng, zoom);
        }

        async function predictForPoint(lat, lng, zoom) {
            console.log('--- Starting predictForPoint ---');
            console.log('Point:', lat, lng, 'Zoom:', zoom);
            showSpinner(true);
            clearAll(); // 清除之前的结果

            try {
                console.log('Fetching prediction for point...');
                const response = await fetch('/predict_point', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        lat: lat, 
                        lng: lng, 
                        zoom: zoom,
                        threshold: parseFloat(document.getElementById('threshold-slider').value),
                        min_area: parseInt(document.getElementById('min-area-slider').value)
                    })
                });

                if (!response.ok) {
                    throw new Error(`点选预测失败: ${response.statusText}`);
                }

                const data = await response.json();
                
                if (data.image && data.bounds) {
                    // 显示下载的图片
                    const imageUrl = `data:image/png;base64,${data.image}`;
                    const imageBounds = L.latLngBounds(
                        [data.bounds._southWest.lat, data.bounds._southWest.lng],
                        [data.bounds._northEast.lat, data.bounds._northEast.lng]
                    );
                    const overlay = L.imageOverlay(imageUrl, imageBounds, {
                        opacity: 0.8,
                        className: 'downloaded-image-overlay'
                    });
                    overlay.addTo(staticMapLayers);
                    
                    // 自动显示静态地图图层
                    if (!map.hasLayer(staticMapLayers)) {
                        map.addLayer(staticMapLayers);
                    }
                }
                
                if (data.geojson && data.geojson.features && data.geojson.features.length > 0) {
                    console.log('Displaying prediction results:', data.geojson);
                    displayResults(data.geojson);
                } else {
                    console.log('No buildings detected');
                    alert('在此区域未检测到建筑物');
                }

            } catch (error) {
                console.error('--- ERROR in predictForPoint ---', error);
                alert('点选预测时出错: ' + error.message);
            } finally {
                showSpinner(false);
            }
        }

        

                map.on(L.Draw.Event.CREATED, function (event) {
            if (currentMode !== 'box') return;
            const layer = event.layer;
            drawnItems.addLayer(layer);
            const bounds = layer.getBounds();
            predictForBounds(bounds);
            // Remove the drawing control to prevent multiple boxes
            if (drawControl) {
                // Instead of removing, just disable the drawing handler
                // This allows the user to draw another box without re-selecting the mode
                new L.Draw.Rectangle(map, drawControl.options.draw.rectangle).disable();
            }
             // Do not switch back to point mode automatically
        });

        

                function setMode(mode) {
            currentMode = mode;
            const pointButton = document.getElementById('btn-point-mode');
            const boxButton = document.getElementById('btn-box-mode');

            if (mode === 'point') {
                pointButton.classList.add('active');
                boxButton.classList.remove('active');
                // 只有在非编辑模式和非标记模式下才绑定点击事件
                if (!editMode && !markerMode) {
                    map.on('click', onMapClick);
                    map.getContainer().style.cursor = 'crosshair';
                } else {
                    map.off('click', onMapClick);
                }
                if (drawControl) {
                    map.removeControl(drawControl);
                    drawControl = null;
                }
            } else { // box mode
                pointButton.classList.remove('active');
                boxButton.classList.add('active');
                map.off('click', onMapClick);
                if (!drawControl) {
                    drawControl = new L.Control.Draw({
                        draw: {
                            polygon: false, 
                            polyline: false, 
                            circle: false, 
                            marker: false,
                            circlemarker: false, // 移除圆圈标记
                            rectangle: { 
                                shapeOptions: { 
                                    color: '#007aff',
                                    weight: 2,
                                    opacity: 0.8,
                                    fillOpacity: 0.1
                                } 
                            }
                        },
                        edit: false
                    });
                    map.addControl(drawControl);
                }
                map.getContainer().style.cursor = '';
                // Manually trigger the rectangle drawing tool
                new L.Draw.Rectangle(map, drawControl.options.draw.rectangle).enable();
            }
        }

        function updateMapCenter() {
            const lon = parseFloat(document.getElementById('lon').value);
            const lat = parseFloat(document.getElementById('lat').value);
            if (!isNaN(lon) && !isNaN(lat)) {
                map.panTo([lat, lon]);
            }
        }

        function lonLatToTile(lon, lat, zoom) {
            const latRad = lat * Math.PI / 180;
            const n = Math.pow(2, zoom);
            const xtile = Math.floor((lon + 180) / 360 * n);
            const ytile = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return [xtile, ytile];
        }

        function tileToLonLat(xtile, ytile, zoom) {
            const n = Math.pow(2, zoom);
            const lon = xtile / n * 360 - 180;
            const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * ytile / n)));
            const lat = latRad * 180 / Math.PI;
            return [lon, lat];
        }

        function getTileBounds(tx, ty, zoom) {
            const [swLon, swLat] = tileToLonLat(tx, ty + 1, zoom);
            const [neLon, neLat] = tileToLonLat(tx + 1, ty, zoom);
            return {
                _southWest: { lat: swLat, lng: swLon },
                _northEast: { lat: neLat, lng: neLon }
            };
        }

        async function predictForBounds(bounds) {
            console.log('--- Starting predictForBounds ---');
            console.log('Received bounds:', bounds);
            showSpinner(true);
            clearAll(); // 清除之前的结果

            // 将绘制的矩形放在地图上
            if (currentMode === 'box') {
                drawnItems.clearLayers(); // 清除之前的矩形框
                L.rectangle(bounds, { color: "#faff00", weight: 2, fillOpacity: 0 }).addTo(drawnItems);
            }

            try {
                const allFeatures = [];
                const zoom = map.getZoom(); // 当前地图缩放级别，用于传递给后端
                const gridZoom = 18; // 固定使用18级进行网格计算，保持授权逻辑一致性

                // 将边界转换为512x512网格的瓦片坐标（基于18级）
                const sw = bounds.getSouthWest();
                const ne = bounds.getNorthEast();
                const [minTx, maxTy] = lonLatToTile(sw.lng, sw.lat, gridZoom);
                const [maxTx, minTy] = lonLatToTile(ne.lng, ne.lat, gridZoom);

                // 计算512x512网格点（每个覆盖2x2瓦片）
                // 需要对齐到512x512边界并确保完全覆盖
                const gridMinTx = Math.floor(minTx / 2) * 2;
                const gridMinTy = Math.floor(minTy / 2) * 2;
                // 确保覆盖所有与选择区域相交的瓦片
                // 先给maxTx/maxTy加1，然后使用Math.ceil向上舍入到下一个偶数
                const gridMaxTx = Math.ceil((maxTx + 1) / 2) * 2;
                const gridMaxTy = Math.ceil((maxTy + 1) / 2) * 2;
                
                console.log(`Tile bounds (zoom ${gridZoom}): minTx=${minTx}, maxTx=${maxTx}, minTy=${minTy}, maxTy=${maxTy}`);
                console.log(`Grid bounds: gridMinTx=${gridMinTx}, gridMaxTx=${gridMaxTx}, gridMinTy=${gridMinTy}, gridMaxTy=${gridMaxTy}`);

                // 计算需要的512x512图片总数
                const totalImages = ((gridMaxTx - gridMinTx) / 2) * ((gridMaxTy - gridMinTy) / 2);
                console.log(`Total 512x512 images needed: ${totalImages}`);

                // 检查大面积区域是否需要授权（15张以上图片）
                if (totalImages >= 15) {
                    const password = prompt(`此操作需要下载 ${totalImages} 张512x512图片，需要授权。\n请输入授权密码：`);
                    if (password !== 'yuntu') {
                        alert('授权密码错误，操作已取消。');
                        return;
                    }
                    console.log('Authorization successful for large area processing.');
                }

                for (let tx = gridMinTx; tx < gridMaxTx; tx += 2) {
                    for (let ty = gridMinTy; ty < gridMaxTy; ty += 2) {
                        // 计算2x2瓦片区域的中心点用于512x512图片（基于18级网格）
                        const centerTx = tx + 1;
                        const centerTy = ty + 1;
                        const [centerLon, centerLat] = tileToLonLat(centerTx, centerTy, gridZoom);

                        console.log(`Fetching 512x512 image for grid ${tx}, ${ty} (center: ${centerLon}, ${centerLat}) with zoom level ${zoom}...`);
                        const staticMapResponse = await fetch('/predict_point', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                lat: centerLat,
                                lng: centerLon,
                                zoom: zoom,  // 传递当前地图缩放级别
                                threshold: parseFloat(document.getElementById('threshold-slider').value),
                                min_area: parseInt(document.getElementById('min-area-slider').value)
                            })
                        });

                        if (!staticMapResponse.ok) {
                            console.error(`网格${tx}, ${ty}的512x512图片获取失败: ${staticMapResponse.statusText}`);
                            continue; // 跳到下一个网格
                        }
                        const staticMapData = await staticMapResponse.json();

                        if (staticMapData.image && staticMapData.bounds) {
                            const imageUrl = `data:image/png;base64,${staticMapData.image}`;
                            const imageBounds = L.latLngBounds(
                                [staticMapData.bounds._southWest.lat, staticMapData.bounds._southWest.lng],
                                [staticMapData.bounds._northEast.lat, staticMapData.bounds._northEast.lng]
                            );
                            // 创建带阴影效果的图片覆盖层
                            const overlay = L.imageOverlay(imageUrl, imageBounds, {
                                opacity: 0.8,
                                className: 'downloaded-image-overlay'
                            });
                            overlay.addTo(staticMapLayers);
                            // 添加瓦片后自动显示静态地图图层
                            if (!map.hasLayer(staticMapLayers)) {
                                map.addLayer(staticMapLayers);
                            }

                            // /predict_point端点已经包含预测结果
                            if (staticMapData.geojson && staticMapData.geojson.features && staticMapData.geojson.features.length > 0) {
                                console.log(`Found ${staticMapData.geojson.features.length} buildings in grid ${tx}, ${ty}`);
                                allFeatures.push(...staticMapData.geojson.features);
                            }
                        }
                    }
                }

                const finalGeoJSON = { type: "FeatureCollection", features: allFeatures };
                console.log('Displaying combined results:', finalGeoJSON);
                displayResults(finalGeoJSON);

            } catch (error) {
                console.error('--- ERROR in predictForBounds ---', error);
                alert('An error occurred: ' + error.message);
            } finally {
                showSpinner(false);
            }
        }

        function toggleStaticMapVisibility() {
            if (map.hasLayer(staticMapLayers)) {
                map.removeLayer(staticMapLayers);
            } else {
                map.addLayer(staticMapLayers);
            }
        }

        function displayResults(geojson) {
            if (buildingLayer) {
                map.removeLayer(buildingLayer);
            }
            currentGeoJSON = geojson; // 存储用于导出
            buildingLayer = L.geoJSON(geojson, {
                style: function (feature) {
                    return { 
                        color: "#ff7800", 
                        weight: 2, 
                        opacity: 0.8,
                        fillOpacity: 0.3,
                        fillColor: "#ff7800"
                    };
                },
                onEachFeature: function(feature, layer) {
                    // 添加点击事件用于编辑
                    layer.on('click', function(e) {
                        if (editMode) {
                            enablePolygonEdit(layer);
                        }
                    });
                    
                    // 添加悬停效果
                    layer.on('mouseover', function(e) {
                        if (editMode) {
                            layer.setStyle({
                                weight: 3,
                                color: '#007aff',
                                fillOpacity: 0.5
                            });
                        }
                    });
                    
                    layer.on('mouseout', function(e) {
                        if (editMode) {
                            layer.setStyle({
                                weight: 2,
                                color: '#ff7800',
                                fillOpacity: 0.3
                            });
                        }
                    });
                }
            }).addTo(map);

            if (geojson && geojson.features && geojson.features.length > 0) {
                document.getElementById('btn-export').disabled = false;
            } else {
                document.getElementById('btn-export').disabled = true;
            }
        }

        async function exportShp() {
            if (!currentGeoJSON) {
                alert('没有可导出的数据。');
                return;
            }

            try {
                showSpinner(true);

                const response = await fetch('/export_shp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ geojson: currentGeoJSON })
                });

                if (!response.ok) {
                    throw new Error('SHP文件导出失败。');
                }

                const blob = await response.blob();

                // 使用传统的文件下载方式，兼容所有浏览器和环境
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'buildings.zip';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                alert('文件已成功下载！');

            } catch (error) {
                console.error('导出错误:', error);
                alert('导出SHP时出错: ' + error.message);
            } finally {
                showSpinner(false);
            }
        }

        function showSpinner(show) {
            document.getElementById('spinner').style.display = show ? 'block' : 'none';
        }
        
        // 切换编辑模式
         function toggleEditMode() {
             editMode = !editMode;
             const btn = document.getElementById('btn-edit-mode');
             const hint = document.getElementById('edit-hint');
             
             if (editMode) {
                 btn.style.backgroundColor = '#007aff';
                 btn.style.color = 'white';
                 btn.textContent = '退出编辑';
                 hint.style.display = 'block';
                 map.getContainer().style.cursor = 'pointer';
                 // 进入编辑模式时移除点选功能
                 map.off('click', onMapClick);
             } else {
                 btn.style.backgroundColor = '#f0f0f0';
                 btn.style.color = '#333';
                 btn.textContent = '编辑建筑物';
                 hint.style.display = 'none';
                 // 退出编辑模式时恢复点选功能（如果在点选模式且非标记模式）
                 if (currentMode === 'point' && !markerMode) {
                     map.on('click', onMapClick);
                     map.getContainer().style.cursor = 'crosshair';
                 } else {
                     map.getContainer().style.cursor = '';
                 }
                 // 禁用所有正在编辑的多边形
                 if (buildingLayer) {
                     buildingLayer.eachLayer(function(layer) {
                         if (layer.editing && layer.editing.enabled()) {
                             layer.editing.disable();
                         }
                     });
                 }
             }
         }
        
        // 切换标记模式
         function toggleMarkerMode() {
             markerMode = !markerMode;
             const btn = document.getElementById('btn-add-marker');
             
             if (markerMode) {
                 btn.style.backgroundColor = '#34c759';
                 btn.style.color = 'white';
                 btn.textContent = '退出标记';
                 map.getContainer().style.cursor = 'crosshair';
                 // 进入标记模式时移除点选功能，添加标记功能
                 map.off('click', onMapClick);
                 map.on('click', addMarker);
             } else {
                 btn.style.backgroundColor = '#f0f0f0';
                 btn.style.color = '#333';
                 btn.textContent = '添加标记点';
                 map.off('click', addMarker);
                 // 退出标记模式时恢复点选功能（如果在点选模式且非编辑模式）
                 if (currentMode === 'point' && !editMode) {
                     map.on('click', onMapClick);
                     map.getContainer().style.cursor = 'crosshair';
                 } else {
                     map.getContainer().style.cursor = '';
                 }
             }
         }
        
        // 添加标记点
        function addMarker(e) {
            if (!markerMode) return;
            
            const marker = L.marker(e.latlng, {
                draggable: true
            }).addTo(markerLayer);
            
            // 添加右键删除功能
            marker.on('contextmenu', function() {
                if (confirm('确定要删除这个标记点吗？')) {
                    markerLayer.removeLayer(marker);
                }
            });
            
            // 添加弹出窗口
            const coords = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
            marker.bindPopup(`<b>标记点</b><br>坐标: ${coords}<br><small>右键删除</small>`).openPopup();
        }
        
        // 启用多边形编辑
        function enablePolygonEdit(layer) {
            if (!editMode) return;
            
            // 禁用其他正在编辑的多边形
            if (buildingLayer) {
                buildingLayer.eachLayer(function(otherLayer) {
                    if (otherLayer !== layer && otherLayer.editing && otherLayer.editing.enabled()) {
                        otherLayer.editing.disable();
                    }
                });
            }
            
            // 启用当前多边形的编辑
            if (layer.editing) {
                if (layer.editing.enabled()) {
                    layer.editing.disable();
                } else {
                    layer.editing.enable();
                    
                    // 添加编辑完成事件
                    layer.on('edit', function() {
                        // 更新 GeoJSON 数据
                        updateGeoJSONFromLayer(layer);
                    });
                }
            }
        }
        
        // 更新 GeoJSON 数据
        function updateGeoJSONFromLayer(editedLayer) {
            if (!currentGeoJSON || !currentGeoJSON.features) return;
            
            // 找到对应的 feature 并更新坐标
            buildingLayer.eachLayer(function(layer) {
                if (layer === editedLayer) {
                    const layerGeoJSON = layer.toGeoJSON();
                    // 这里可以添加更复杂的匹配逻辑
                    // 简单起见，我们重新生成整个 GeoJSON
                    const newFeatures = [];
                    buildingLayer.eachLayer(function(l) {
                        newFeatures.push(l.toGeoJSON());
                    });
                    currentGeoJSON.features = newFeatures;
                }
            });
        }
        
        // 清除所有内容（包括标记点）
        function clearAllLayers() {
            staticMapLayers.clearLayers();
            if (buildingLayer) {
                map.removeLayer(buildingLayer);
                buildingLayer = null;
            }
            drawnItems.clearLayers();
            markerLayer.clearLayers();
            currentGeoJSON = null;
            document.getElementById('btn-export').disabled = true;
        }

        // 模型切换相关函数
        async function loadAvailableModels() {
            try {
                const response = await fetch('/get_models');
                const data = await response.json();
                
                const selector = document.getElementById('modelSelector');
                selector.innerHTML = '';
                
                data.models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.name;
                    option.textContent = `${model.name} ${model.available ? '' : '(不可用)'}`;
                    option.disabled = !model.available;
                    if (model.name === data.current) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
                
                console.log('可用模型加载完成:', data);
            } catch (error) {
                console.error('加载模型列表失败:', error);
                const selector = document.getElementById('modelSelector');
                selector.innerHTML = '<option value="">加载失败</option>';
            }
        }
        
        async function switchModel() {
            const selector = document.getElementById('modelSelector');
            const selectedModel = selector.value;
            
            if (!selectedModel) return;
            
            try {
                showSpinner(true);
                
                const response = await fetch('/switch_model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_name: selectedModel })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('模型切换成功:', data.message);
                    alert(`模型切换成功: ${data.message}`);
                } else {
                    console.error('模型切换失败:', data.error);
                    alert(`模型切换失败: ${data.error}`);
                    // 重新加载模型列表以恢复正确的选择
                    await loadAvailableModels();
                }
            } catch (error) {
                console.error('模型切换请求失败:', error);
                alert('模型切换请求失败，请检查网络连接');
                // 重新加载模型列表以恢复正确的选择
                await loadAvailableModels();
            } finally {
                showSpinner(false);
            }
        }

        // 初始化设置
        document.addEventListener('DOMContentLoaded', function() {
            setMode('point');
            // 加载可用模型
            loadAvailableModels();
            // 地图移动时更新坐标
            map.on('move', function() {
                const center = map.getCenter();
                document.getElementById('lat').value = center.lat.toFixed(6);
                document.getElementById('lon').value = center.lng.toFixed(6);
            });
        });

    </script>
</body>
</html>